1.  合理选择装饰器

    1.  最小化状态共享范围

        1.  在没有强烈的业务需求下，尽可能按照状态需要共享的最小范围选择合适的装饰器。
        2.  应用开发过程中，按照组件颗粒度，状态一般分为组件内独享的状态和组件间需要共享的状态。
    2.  组件内独享的状态

        1.  @State装饰器
    3.  组件间需要共享的状态（3种场景）

        1.  父子组件间
        2.  不同子树上组件间
        3.  不同组件树间
    4.  对于上述三种场景，ArkUI提供了（6种装饰器组合）

        1.  @State+\@Prop
        2.  @State+\@Link
        3.  @State+\@Observed+\@ObjectLink
        4.  @Provide+\@Consume
        5.  AppStorage
        6.  LocalStorage
    5.  按照共享范围能力从小到大，各装饰器组合的共享范围能力和生命周期

        1.  @State+\@Prop、@State+\@Link、@State+\@Observed+\@ObjectLink：

            1.  三者的共享范围为从@State所在的组件开始，
            2.  到@Prop/@Link/ObjectLink所在组件的整条路径，
            3.  路径上所有的中间组件通过@Prop/@Link/@ObjectLink都可以共享同一个状态。
            4.  @State修饰的状态和其所属的自定义组件共享生命周期，在组件内定义时创建，组件销毁时被回收。
            5.  @Link装饰的变量和其所属的自定义组件共享生命周期。
            6.  @ObjectLink装饰的变量和其所属的自定义组件共享生命周期。
        2.  @Provide+\@Consume：

            1.  状态共享范围是以@Provide所在组件为祖先节点的整棵子树，
            2.  子树上的任意后代组件通过@Consume都可以共享同一个状态。
            3.  @Provide修饰的变量与其所属的组件绑定，在组件内定义时被创建，在组件销毁时被回收。
        3.  LocalStorage：

            1.  共享范围为UIAbility内以页面为单位的不同组件树间的共享。
            2.  存储在LocalStorage中的状态的生命周期与LocalStorage绑定。
            3.  LocalStorage的声明周期由应用程序决定，当应用释放最后一个指向LocalStorage的引用时，LocalStorage被垃圾回收。
        4.  AppStorage：

            1.  共享范围是应用全局。
            2.  AppStorage与应用的进程绑定，由UI框架在应用程序启动时创建，当应用进程终止，AppStorage被回收。
            3.  存储在AppStorage中的状态的生命周期与LocalStorage绑定。
    6.  选择共享范围能力小的装饰器方案，减少不同模块间的数据耦合，便于状态及时回收

        1.  @State+\@Prop、@State+\@Link、@State+\@Observed+\@ObjectLink >
        2.  @Provide+\@Consume >
        3.  LocalStorage >
        4.  AppStorage
    7.  减少不必要的参数层层传递

        1.  @Provide+\@Consume
    8.  按照状态复杂度选择装饰器

|                 | @State + @Prop                                  | @State + @Link                                  | @State + @Observed + @ObjectLink |
| :-------------- | :---------------------------------------------- | :---------------------------------------------- | :------------------------------- |
| 支持接收类型          | Object、class、string、number、boolean、enum及这些类型的数组 | Object、class、string、number、boolean、enum及这些类型的数组 | 被@Observed装饰的类实例、                |
| 支持观察复杂类型的二层属性变化 | 否                                               | 否                                               | 是                                |
| 监听机制            | 父到子的单向绑定                                        | 父子间双向绑定                                         | 父子间双向绑定                          |
| 父修改同步子          | 是                                               | 是                                               | 是                                |
| 子修改同步你          | 否                                               | 是                                               | 是，不可改变本身，只能改变属性                  |
| 内存消耗            | 高                                               | 低                                               | 低                                |
| 修改复杂类型方式        | 深拷贝                                             | 共享同一地址                                          | 共享同一地址                           |

*   结合以上三个方案的特性，在选择时有如下建议

    1.  需要观察嵌套类对象的深层属性变化的场景，选择@State+\@Observed+\@ObjectLink
    2.  状态是复杂对象、类或其类型数组的场景，选择@State+\@Link
    3.  状态是简单数据类型时，使用@State+\@Link和@State+\@Prop均可

        1.  @State+\@Prop适合用于非实时修改的场景，

            1.  如编辑电话薄联系人信息时，展示编辑界面的子组件信息的修改要求不实时同步回父组件，需要等到编辑完成后点击“确认”按钮时才会以事件驱动的方式修改父组件的状态。
        2.  依据@Link双向绑定的特性，@State+\@Link适合用于实时修改的场景，

            1.  如组件嵌套时的滚动条同步
    4.  总结——合理选择装饰器主要包含以下三步

        1.  首先根据状态需要共享的范围大小，尽量选择共享能力小的装饰器方案，优先级依次为@State+\@Prop、@State+\@Link或@State+\@Observed+\@ObjectLink > @Provide+\@Consume > LocalStorage > AppStorage
        2.  当共享的状态的组件间层级相差较大时，为避免较差的代码可扩展性和可维护性，@Provide+\@Consume的方案要优于层层传递的共享方案
        3.  对于具有相同优先级的@State+\@Prop、@State+\@Link或@State+\@Observed+\@ObjectLink 三个方案，应结合状态的复杂程度和装饰器各自的特性选择
*   总结——整体可参考如下建议

    1.  @State+\@Prop：

        1.  适合状态结构简单，且共享状态的组件间层级相差不大的场景。
        2.  或功能上要求子组件不实时同步修改给父组件的场景
    2.  @State+\@Link：

        1.  适合状态结构复杂，且共享状态的组件间层级相差不大的场景。
        2.  或功能上要求子组件对状态的修改实时同步给父组件的场景
    3.  @State+\@Observed+\@ObjectLink：

        1.  适合需要观察嵌套类对象的子属性变化的场景或对象数组的数据项属性变化的场景，如监听列表卡片上某个属性的变化
    4.  @Provide+\@Consume：

        1.  适合用于对于整个组件树而言“全局”的状态，且该状态改动不频繁的状态共享场景，如共享界面的路由信息
    5.  LocalStorage：

        1.  适合对于单个Ability而言“全局”的变量，主要用于不同页面间的状态共享场景
    6.  AppStorage：

        1.  适合对于整个应用而言“全局”的变量或应用的主线程内多个UIAbility实例间的状态共享，如用户信息
*   精细化拆分复杂状态

    1.  收藏信息也是用户信息的一部分，将收藏信息作为用户信息userData的一个属性，存储在当前AppStorage里key值为“userData”的变量上
    2.  收藏信息单独存入AppStorage中，不与用户信息userData绑定
    3.  过分追求状态结构拆分可能在某些场景导致组件设计过度，不利于维护

        1.  可以将对象或类上经常一起改变的几个属性聚合成一个新的对象或类模型，并使用@Observed装饰器修饰，再作为属性挂载到之前的对象或类上。通过此方法，当属性变化时ArkUI只会通知变化给新的对象或类，不会通知最上层的对象。这样既可以有效的减少无用渲染次数，又能使代码更好维护
*   集中化状态修改逻辑

    1.  在使用@Link装饰器时，开发者可以直接在@Link装饰器接收状态的组件内部修改状态。当多个子组件修改状态的逻辑基本相同时，建议将状态的修改集中到单个函数中，以提升逻辑的可复用性、代码的可维护性和可测试性
    2.  如在“HOMS世界App”的探索模块首页上点击资讯卡片、文章卡片或顶部轮播图时，都会跳转到详情页
*   总结

    1.  在选择装饰器时，应理解各个装饰器的特性和共享范围，结合实际开发场景的优先级，合理选择装饰器，以确保状态和视图的一致性
    2.  在使用装饰器时，对装饰器修饰的复杂变量应进行合理拆分设计，以此减少非必要的组件渲染次数，获得更好的性能体验
    3.  在代码开发过程中，对相似的逻辑处理，应考虑其复用性合理集中处理，以此有效提升代码的可维护性和可复用性

