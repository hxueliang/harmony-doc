1.  ArkTS 高性能编程

    1.  一些 TS 的特性被限制

        1.  不支持属性的动态变更
        2.  变量或参数要明确类型声明和返回值声明
        3.  不支持 any 和 unknown

    2.  严格遵循 ArkTS 的编码规则

        1.  禁用@ts-ignore @ts-expect-error 等屏蔽编译校验的命令

    3.  开启 TS 的严格模式

        1.  严格判空
        2.  严格函数类型检查
        3.  严格成员初始化
        4.  等等

    4.  使用 AOT 模式
        ![未启用AOT](../static/image/应用性能优化/未启用AOT.png '未启用AOT')
        ![启用AOT](../static/image/应用性能优化/启用AOT.png '启用AOT')

2.  提升应用的启动和响应速度

    1.  提升应用冷启动

        1.  缩短应用进程创建&初始化阶段耗时

            1.  设置合适分辨率的 startWindowIcon

        2.  缩短 Application\&Ability 初始化阶段耗时

            1.  减少首页 Ability 或者 Page 中 import 的模块

        3.  缩短 Ability 生命周期阶段耗时

            1.  使用异步加载

        4.  缩短加载绘制首页阶段耗时

            1.  使用延迟加载

    2.  使用异步加载

        1.  生命周期中，调用的耗时的同步任务，改为异步任务

    3.  动态加载

        1.  `await import('url')`

    4.  延迟加载

        1.  长列表场景中，使用`LazyForEach`替代`ForEach`，

    5.  缓存

        1.  `LazyForEach`搭配使用`cachedCount`

3.  减少丢帧卡顿

    1.  避免在主线程上执行耗时操作

        1.  `TaskPool`
        2.  `Worker`

    2.  减少渲染进程的冗余开销

        1.  使用资源图代替绘制
        2.  将组件进行离屏绘制

            1.  `.renderGroup(true)`
            2.  前提组件的内容是不会变化的

        3.  尺寸位置设置尽量使用整数
        4.  动画参数相同时

            1.  能使用一个`animateTo`，不使用多个

                1.  减少底层 animateTo 的创建数
                2.  减少了状态对比次数

        5.  避免多个 animateTo 之间做状态更新
        6.  组件转场动画

            1.  推荐使用`transition`

                1.  只需要判断初始状态或结束状态，即判断一种状态
                2.  代码量较少，可维护性强

            2.  不推荐属性动画+动画结束回调，即`animateTo`

                1.  需要判断初始状态和结束状态，即判断两种状态
                2.  代码量较多

    3.  减少视图嵌套层级

        1.  `List`
        2.  `RelativeContainer`
        3.  `Grid`

    4.  组件复用 - 如`LazyForEach`子项 或 反复切换条件渲染的控制分支中的组件子树

        1.  `@Reusable`修改需要复用的组件
        2.  `aboutToReuse(params)`更新复用组件的数据

    5.  精确控制状态变量的关联组件数 - @State 等状态变量关联组件越多，状态变更时刷新组件越多

        1.  推荐使用状态变量和组件绑定的方式，以数据驱动组件刷新（声明式）。不推荐使用单个状态变量，自行控制多个组件更新时机（命令式）
        2.  合理控制状态更新范围，避免关联刷新较大范围或者渲染较慢的组件

            1.  `@State obj{a,b,c}` => `@State obj{a,b}; @State b`，部分情况下不用考虑，在发生性能问题时，再来考虑是不是类封装的不够好

    6.  在对象上谨慎使用状态变量关联

        1.  理解`@Prop`和`@ObjectLink`的区别

            1.  @Prop 是深拷贝
            2.  @ObjectLink 是浅拷贝

        2.  所以在效果相同的场景下，优先使用@ObjectLink 方式，可减少系统内存开销

4.  使用性能工具，即 DevDco Profiler 调优工具

    1.  ArkUI Inspector:用于检查和调试应用程序页面布局的情况
    2.  Launch Insight:录制和还原从启动应用,到显示首帧过程中的 CPU、内存等资源使用情况,用于分析启动耗时长的问题。
    3.  Frame Insight :录制卡顿过程中的关键数据,标注出应用侧、RenderService 侧卡顿帧,用于分析应用卡顿、丢帧的问题。
    4.  Time Insight :通过周期性采集调用栈,识别 CPU 耗时高的热点代码段,用于分析卡顿、CPU 占用高、运行速度慢等问题。
    5.  Allocation Insight :录制和分析内存分配记录,用于分析内存峰值高,内存泄漏,内存不足导致应用被强杀等问题。
    6.  Snapshot Insight :录制和分析应用程序中 ArkTS 对象的分布,通过快照方式对比 ArkTs 对象分布区别,用于分析内存泄漏问题。
    7.  CPU Insight :录制 CPU 调度事件、线程运行状态、CPU 核频率、Trace 等数据,可用于分析卡顿、运行速度慢、应用无响应等问题
    8.  Smart Perf:开源性能调优平台,支持对 CPU 调度、频点、进程线程时间片、堆内存、帧率等数据进行采集和展示,展示方式为泳道图
